/* eslint-disable prefer-destructuring */
/* eslint-disable no-restricted-properties */
/* eslint-disable prefer-exponentiation-operator */
/* eslint-disable no-param-reassign */
/* global _ */
/* global angular */
/* global CURRENT_USER */
/* global google */
/* global I18n */
/* global iNatModels */
/* global iNaturalist */
/* global loadMap3 */
/* global moment */
/* global PREFERRED_MAP_TYPE */
/* global PREFERRED_PLACE */
/* global PREFERRED_SEARCH_PLACE */
/* global PREFERRED_SUBVIEW */
/* global Promise */
/* global SELECTED_TAXON_ID */
/* global TIMEZONE */
/* global updateSession */

var initializeSearchController;
var initializeMapController;

var googleMapsIsLoaded = function ( ) {
  if ( typeof ( google ) === "undefined"
    || typeof ( google.maps ) === "undefined"
    || typeof ( google.maps.places ) === "undefined"
  ) {
    return false;
  }
  return true;
};

var googleMapsBoundsToObject = function ( googleMapsBounds ) {
  return {
    swlat: googleMapsBounds.getSouthWest( ).lat( ),
    swlng: googleMapsBounds.getSouthWest( ).lng( ),
    nelat: googleMapsBounds.getNorthEast( ).lat( ),
    nelng: googleMapsBounds.getNorthEast( ).lng( )
  };
};

$( function ( ) {
  google.maps.importLibrary( "maps" ).then( function ( ) {
    return google.maps.importLibrary( "drawing" );
  } ).then( function ( ) {
    return google.maps.importLibrary( "geometry" );
  } ).then( function ( ) {
    return google.maps.importLibrary( "places" );
  } )
    .then( function ( ) {
      loadMap3( );
      initializeSearchController( );
      initializeMapController( );
    } )
    .catch( function ( e ) {
      console.log( e );
    } );
} );

var application = angular.module( "ObservationSearch", [
  "infinite-scroll",
  "templates",
  "ehFilters", // angular-capitalize
  "iNatAPI",
  "ui.bootstrap",
  "angularMoment",
  "truncate"
] );

// used for displaying HTML returned from methods
application.filter( "sanitize", ["$sce", function ( $sce ) {
  return function ( safeHTML ) {
    return $sce.trustAsHtml( safeHTML );
  };
}] );

// Load translations for moment if available
// http://stackoverflow.com/a/22965260
var shortRelativeTime = ( I18n.t( "momentjs" ) || {} ).shortRelativeTime;
if ( !shortRelativeTime && I18n.locale.toString( ).indexOf( "-" ) > 0 ) {
  var lang = I18n.locale.split( "-" )[0];
  shortRelativeTime = ( I18n.t( "momentjs", { locale: lang } ) || {} ).shortRelativeTime;
}
if ( shortRelativeTime ) {
  moment.locale( I18n.locale, { relativeTime: shortRelativeTime } );
}

// defining the views
application.directive( "resultsMap", function ( ) {
  return {
    templateUrl: "ang/templates/observation_search/results_map.html",
    link: function ( scope, element, attr ) {
      scope.$watch( attr.ngShow, function ( value ) {
        if ( value === true ) {
          if ( scope.$parent.mapNeedsAligning ) { scope.setMapLayers( true ); }
        }
      } );
      // the observation div on the map is a scrollable div in a scrollable page
      // make sure that when you scroll to the botton of that div, the page
      // doesn't start scrolling down
      $( "#obs" ).isolatedScroll( );
    }
  };
} );

application.config( ["$locationProvider", function ( $locationProvider ) {
  $locationProvider.html5Mode( {
    enabled: true
  } );
}] );

if ( TIMEZONE ) {
  application.constant( "angularMomentConfig", { timezone: TIMEZONE } );
}

application.controller( "SearchController", ["ObservationsFactory", "PlacesFactory",
  "TaxaFactory", "shared", "$scope", "$rootScope", "$location", "$anchorScroll", "$uibPosition",
  function (
    ObservationsFactory,
    PlacesFactory,
    TaxaFactory,
    shared,
    $scope,
    $rootScope,
    $location,
    $anchorScroll
  ) {
    SearchController(
      ObservationsFactory,
      PlacesFactory,
      TaxaFactory,
      shared,
      $scope,
      $rootScope,
      $location,
      $anchorScroll
    );
    initializeSearchController = function ( ) {
      $scope.drawing.manager = new google.maps.drawing.DrawingManager( );
      $scope.shapeMap = {
        rectangle: {
          mode: google.maps.drawing.OverlayType.RECTANGLE,
          options: {
            rectangleOptions: _.extend( { }, $scope.boundaryBoxStyle, {
              editable: true,
              draggable: false,
              suppressUndo: true
            } )
          }
        },
        circle: {
          mode: google.maps.drawing.OverlayType.CIRCLE,
          options: {
            circleOptions: _.extend( { }, $scope.boundaryBoxStyle, {
              editable: true,
              draggable: false,
              suppressUndo: true
            } )
          }
        }
      };
      $scope.setupPlaceSearchbox( );
    };
  }
] );

var SearchController = function (
  ObservationsFactory,
  PlacesFactory,
  TaxaFactory,
  shared,
  $scope,
  $rootScope,
  $location,
  $anchorScroll
) {
  $scope.currentUser = CURRENT_USER && CURRENT_USER.id ? CURRENT_USER : null;
  $scope.shared = shared;
  $scope.possibleViews = ["observations", "species", "identifiers", "observers"];
  $scope.possibleSubviews = { observations: ["map", "grid", "table"] };
  $scope.possibleFields = ["iconic_taxa", "month", "swlat", "swlng",
    "nelat", "nelng", "place_id", "taxon_id", "page", "view", "subview",
    "locale", "preferred_place_id", "ident_user_id", "spam"];
  $scope.defaultView = "observations";
  $scope.defaultSubview = "grid";
  $rootScope.mapType = "map";
  $rootScope.mapLabels = true;
  $rootScope.mapTerrain = false;
  $scope.defaultParams = {
    verifiable: true,
    order_by: "observations.id",
    order: "desc",
    page: 1,
    spam: false
  };
  $scope.earthRadiusInKm = 6371;
  $scope.dragIconOffset = 20;
  $scope.dragRectDeltaXInPx = null;
  $scope.dragRectDeltaYInPx = null;
  $scope.dragCircleDeltaInKm = null;
  $scope.nearbyPlaces = null;
  $scope.disableRedoSearch = true;
  $scope.taxonInitialized = false;
  $scope.placeInitialized = false;
  $scope.filtersInitialized = false;
  $scope.parametersInitialized = false;
  $scope.moreFiltersHidden = true;
  $scope.moreFiltersToWatch = ["params.user_id", "params.project_id",
    "params.photo_license", "params.reviewed", "params.created_on",
    "params.created_month", "params.created_d1", "params.created_d2",
    "clickedMoreFiltersOpen"];
  $scope.drawing = {
    disabled: false,
    currentShape: null,
    dragIcon: null,
    pendingDrawing: null
  };
  $scope.$watchGroup( ["mapType", "mapLabels", "mapTerrain"], function ( ) {
    $rootScope.$emit( "setMapType", $scope.mapType, $scope.mapLabels, $scope.mapTerrain );
  } );
  // this is the first block to run when the page loads
  $scope.preInitialize = function ( ) {
    $scope.resetStats( ); // all stats read ---
    $scope.setInitialParams( ); // set params from URL, lookup place and taxon
    $scope.matchUrlState( ); // set the right view
  };
  // small usability improvement for people who use their keyboards. Allows
  // users to ESC out of drawing a shape after having clicked a shape icon
  $( document ).keydown( function ( e ) {
    if ( e.key === "Escape" ) {
      var scope = angular.element(
        document.getElementsByClassName( "map-shape-controls" )[0]
      ).scope( );
      if ( scope.drawing.pendingDrawing && scope.currentSubview === "map" ) {
        scope.clearBoundary( );
        scope.$apply( );
      }
    }
  } );
  // shared styles for map places and shapes. Needed to be inline for Google styling
  $scope.boundaryBoxStyle = {
    strokeColor: "#f16f3a",
    strokeOpacity: 0.8,
    strokeWeight: 5,
    fillOpacity: 0
  };

  // once the initial state is prepared from the URL and params loaded
  $scope.afterParametersInitialized = function ( ) {
    if ( $scope.taxonInitialized && $scope.placeInitialized
      && $scope.filtersInitialized && !$scope.parametersInitialized ) {
      // fetch the observations
      $scope.searchAndUpdateStats( { browserStateOnly: true } );
      // set proper map layers for the search and orient the map
      $rootScope.$emit( "setMapLayers", true );
      // now we watch for param changes
      $scope.watchParams( );
      $scope.parametersInitialized = true;
    }
  };
  // any time an initialization step finishes, attempt afterInitialize
  $scope.$watchGroup( [
    "taxonInitialized", "filtersInitialized", "placeInitialized"
  ], function ( ) {
    $scope.afterParametersInitialized( );
  } );
  // runs when the filters template has been rendered
  $scope.onFiltersLoad = function ( ) {
    $scope.setupFilterToggle( );
    $scope.setupDatepicker( );
    $scope.determineFieldNames( );
    $scope.setupTaxonAutocomplete( );
    $scope.setupInatPlaceAutocomplete( );
    $scope.setupUserAutocomplete( );
    $scope.setupProjectAutocomplete( );
    $scope.setupBrowserStateBehavior( );
    $scope.filtersInitialized = true;
    // someone searched with taxon_name, but no matching taxon was found,
    // so focus and click on the field to present the autocomplete results
    if ( $scope.params.taxon_name && !SELECTED_TAXON_ID ) {
      $( "#filters input[name='taxon_name']" ).focus( ).click( );
    }
  };
  $scope.toRadians = function ( degrees ) { return ( degrees * Math.PI ) / 180; };
  $scope.toDegrees = function ( radians ) { return ( radians * 180 ) / Math.PI; };
  $scope.latLng2Point = function ( latLng, map ) {
    var topRight = map.getProjection( ).fromLatLngToPoint( map.getBounds( ).getNorthEast( ) );
    var bottomLeft = map.getProjection( ).fromLatLngToPoint( map.getBounds( ).getSouthWest( ) );
    var scale = Math.pow( 2, map.getZoom( ) );
    var worldPoint = map.getProjection( ).fromLatLngToPoint( latLng );
    return new google.maps.Point(
      ( worldPoint.x - bottomLeft.x ) * scale,
      ( worldPoint.y - topRight.y ) * scale
    );
  };
  $scope.point2LatLng = function ( point, map ) {
    var topRight = map.getProjection( ).fromLatLngToPoint( map.getBounds( ).getNorthEast( ) );
    var bottomLeft = map.getProjection( ).fromLatLngToPoint( map.getBounds( ).getSouthWest( ) );
    var scale = Math.pow( 2, map.getZoom( ) );
    var worldPoint = new google.maps.Point(
      point.x / scale + bottomLeft.x,
      point.y / scale + topRight.y
    );
    return map.getProjection( ).fromPointToLatLng( worldPoint );
  };
  $scope.getHaversineDistanceInKm = function ( point1, point2 ) {
    var lat1Rad = $scope.toRadians( point1.lat );
    var lat2Rad = $scope.toRadians( point2.lat );
    var latDiff = lat2Rad - lat1Rad;
    var lonDiff = $scope.toRadians( point2.lng - point1.lng );
    return 2 * $scope.earthRadiusInKm * Math.asin( Math.sqrt(
      ( Math.sin( latDiff / 2 ) * Math.sin( latDiff / 2 ) ) + (
        Math.cos( lat1Rad ) * Math.cos( lat2Rad )
        * Math.sin( lonDiff / 2 ) * Math.sin( lonDiff / 2 )
      )
    ) );
  };
  $scope.getCircleBounds = function ( lat, lng, radius ) {
    var deltaLat = $scope.toDegrees( radius / $scope.earthRadiusInKm );
    var deltaLng = $scope.toDegrees(
      radius / $scope.earthRadiusInKm / Math.cos( $scope.toRadians( lat ) )
    );
    var sw = new google.maps.LatLng( lat - deltaLat, lng - deltaLng );
    var ne = new google.maps.LatLng( lat + deltaLat, lng + deltaLng );
    return new google.maps.LatLngBounds( sw, ne );
  };
  $scope.resetStats = function ( ) {
    _.each( ["totalObservations", "totalSpecies", "totalObservers", "totalIdentifiers"], function ( k ) {
      $scope[k] = "--";
    } );
    _.each( ["taxa", "identifiers", "observers"], function ( k ) {
      $scope[k] = [];
    } );
    if ( !$scope.$$phase ) { $scope.$digest( ); }
  };
  $scope.resetParams = function ( ) {
    var resetParams = _.extend( { }, $scope.defaultParams );
    if ( $scope.preferredPlaceObject ) {
      resetParams.place_id = $scope.preferredPlaceObject.id;
    }
    $scope.params = _.extend( { }, $scope.defaultParams );
    // reset taxon autocomplete
    $( "#filters input[name='taxon_name']" ).trigger( "resetAll" );
    // reset place autocomplete
    $scope.selectedPlace = $scope.preferredPlaceObject;
    $scope.searchedPlace = null;
    $scope.placeSearch = null;
    $scope.closeFilters( );
  };
  $scope.closeFilters = function ( ) {
    $( "#filter-container" ).removeClass( "open" );
  };
  $scope.watchParams = function ( ) {
    // params may change but not affect the results
    // for example DateType will change with the different date options
    $scope.$watch( "params", function ( newValue, oldValue ) {
      $scope.processedParams = ObservationsFactory.processParamsForAPI(
        $scope.params,
        $scope.possibleFields
      );
      if ( CURRENT_USER ) {
        $scope.showingViewerObservations = (
          ( $scope.processedParams.user_id === CURRENT_USER.id )
          || ( $scope.processedParams.user_id === CURRENT_USER.login )
        );
      }
      if ( _.isEqual( newValue, oldValue ) ) {
        return;
      }
      // if any of the filters change we want to reset the page to 1.
      // when pagination, the page will change, so if the page doesn't
      // change, then the user is changing another filter, so go to page 1
      if ( newValue.page === oldValue.page ) {
        $scope.params.page = 1;
      }
    }, true );
    // changes in processedParams are what initiate searches
    $scope.$watch( "processedParams", function ( before, after ) {
      if ( _.isEqual( before, after ) ) {
        return;
      }
      // when paginating we do want to set processedParams, but we don't
      // want to query for the stats again as they will stay the same
      if ( $scope.skipParamChange ) {
        $scope.skipParamChange = false;
        return;
      }
      // we don't want to set the location on page load, it will already be set
      $scope.searchAndUpdateStats( { skipSetLocation: $scope.goingBack } );
      $rootScope.$emit( "setMapLayers", $scope.alignMapOnSearch );
      // restore some one-time search settings
      $scope.alignMapOnSearch = false;
      $scope.goingBack = false;
      $scope.pagingInitialized = true;
    }, true );
  };
  $scope.toggleMoreFilters = function ( ) {
    $scope.clickedMoreFiltersOpen = !$scope.clickedMoreFiltersOpen;
  };
  // watch more filters to determine whether to show them or not
  $scope.$watchGroup( $scope.moreFiltersToWatch, function ( newValues, oldValues, scope ) {
    var pageInit = _.isEqual( newValues, oldValues );
    if ( $scope.clickedMoreFiltersOpen ) {
      scope.moreFiltersHidden = false;
      return;
    }
    if ( !$scope.clickedMoreFiltersOpen === false ) {
      scope.moreFiltersHidden = true;
      return;
    }
    var moreFiltersHidden = true;
    _.each( scope.moreFiltersToWatch, function ( f ) {
      if ( newValues[$scope.moreFiltersToWatch.indexOf( f )] ) {
        moreFiltersHidden = false;
      }
    } );
    if ( pageInit && $scope.clickedMoreFiltersOpen === null && !moreFiltersHidden ) {
      $scope.clickedMoreFiltersOpen = true;
    }
    scope.moreFiltersHidden = moreFiltersHidden;
  } );
  $scope.$watch( "params.user_id", function ( ) {
    $scope.updateUserAutocomplete( );
  } );
  $scope.$watch( "params.project_id", function ( ) {
    $scope.updateProjectAutocomplete( );
  } );
  // watch for place selections, unselections
  $scope.$watch( "selectedPlace", function ( ) {
    if ( $scope.selectedPlace && $scope.selectedPlace.id ) {
      if ( $scope.params.place_id !== $scope.selectedPlace.id ) {
        $scope.mapBounds = null;
        $scope.alignMapOnSearch = true;
        $scope.params.place_id = $scope.selectedPlace.id;
        $scope.updatePlaceAutocomplete( );
      }
    } else if ( !Array.isArray( $scope.params.place_id ) ) {
      $scope.alignMapOnSearch = false;
      $scope.params.place_id = "any";
      $scope.updatePlaceAutocomplete( );
    }
    if ( $scope.drawing.pendingDrawing ) {
      $scope.drawing.manager.setMap( null );
      $scope.drawing.pendingDrawing = null;
      $scope.$apply( );
    }
  } );
  $scope.initializeTaxonParams = function ( ) {
    if ( $scope.params.taxon_id ) {
      $scope.params.taxon_id = parseInt( $scope.params.taxon_id, 10 );
    }
    if ( $scope.params.taxon_id ) {
      // load taxon auto name and photo for autocomplete. Send locale
      // params to we load the right taxon name for the users's prefs
      TaxaFactory.show( $scope.params.taxon_id, iNaturalist.localeParams( ) )
        .then( function ( response ) {
          var taxa = TaxaFactory.responseToInstances( response );
          if ( taxa.length > 0 ) {
            $scope.selectedTaxon = taxa[0];
          }
          $scope.updateTaxonAutocomplete( );
          $scope.taxonInitialized = true;
        } );
    } else {
      // this will remove the autocomplete image since there's no taxon
      $scope.updateTaxonAutocomplete( );
      $scope.taxonInitialized = true;
    }
  };
  $scope.initializePlaceParams = function ( ) {
    $scope.params.place_id = $scope.params["place_id[]"] || $scope.params.place_id;
    if ( _.isString( $scope.params.place_id ) ) {
      $scope.params.place_id = _.filter( $scope.params.place_id.split( "," ), _.identity );
    }
    if ( Array.isArray( $scope.params.place_id ) && $scope.params.place_id.length === 1 ) {
      $scope.params.place_id = $scope.params.place_id[0];
    }
    if ( $scope.params.place_id && !Array.isArray( $scope.params.place_id ) ) {
      $scope.params.place_id = parseInt( $scope.params.place_id, 10 );
    }
    if ( $scope.params.place_id && !Array.isArray( $scope.params.place_id ) ) {
      // load place name and polygon from ID
      PlacesFactory.show( $scope.params.place_id ).then( function ( response ) {
        var places = PlacesFactory.responseToInstances( response );
        if ( places.length > 0 ) {
          if ( PREFERRED_PLACE && places[0].id === PREFERRED_PLACE.id ) {
            $scope.preferredPlaceObject = places[0];
          }
          $scope.filterByPlace( places[0] );
        }
        $scope.placeInitialized = true;
      } );
    } else {
      // otherwise set the starting mapBounds
      if ( $scope.params.swlat && $scope.params.swlng
        && $scope.params.nelat && $scope.params.nelng ) {
        $scope.drawing.currentShape = "rectangle";
        $scope.drawing.disabled = true;
        $scope.mapBounds = {
          swlat: $scope.params.swlat,
          swlng: $scope.params.swlng,
          nelat: $scope.params.nelat,
          nelng: $scope.params.nelng
        };
      } else if ( $scope.params.lat && $scope.params.lng && $scope.params.radius ) {
        $scope.drawing.currentShape = "circle";
        $scope.drawing.disabled = true;
      }
      $scope.placeInitialized = true;
    }
  };
  // set params from the URL and lookup any Taxon or Place selections
  $scope.setInitialParams = function ( ) {
    var initialParams = _.extend( { }, $scope.defaultParams, $location.search( ) );
    if ( initialParams.verifiable === "true" ) {
      initialParams.verifiable = true;
    }
    // turning the key taxon_ids[] into taxon_ids
    if ( initialParams["taxon_ids[]"] ) {
      initialParams.taxon_ids = initialParams["taxon_ids[]"];
      delete initialParams["taxon_ids[]"];
    }
    // setting iconic_taxa_hash for the iconic taxa filters, (e.g { Chromista: true })
    if ( initialParams.iconic_taxa ) {
      initialParams.iconic_taxa_hash = _.fromPairs( _.map(
        initialParams.iconic_taxa.split( "," ),
        function ( n ) { return [n, true]; }
      ) );
    }
    // set the default user or site place_id
    if ( PREFERRED_SEARCH_PLACE && !ObservationsFactory.hasSpatialParams( initialParams ) ) {
      initialParams.place_id = PREFERRED_SEARCH_PLACE.id;
    }
    if ( PREFERRED_SUBVIEW && !initialParams.subview ) {
      $scope.currentSubview = PREFERRED_SUBVIEW;
    }
    // use the current user's id as the basis for the `reviewed` param
    if ( initialParams.reviewed !== undefined && !initialParams.reviewed_by && CURRENT_USER ) {
      initialParams.viewer_id = CURRENT_USER.id;
    }
    // a taxon_name param was provided, and a match was found,
    // so use taxon_id and remove taxon_name
    if ( initialParams.taxon_name && SELECTED_TAXON_ID && !initialParams.taxon_id ) {
      initialParams.taxon_id = SELECTED_TAXON_ID;
      delete initialParams.taxon_name;
    }
    // months from URLs need to be turned into arrays
    if ( initialParams.month ) { initialParams.month = initialParams.month.split( "," ); }
    $scope.params = initialParams;
    $scope.initializeTaxonParams( );
    $scope.initializePlaceParams( );
  };
  $scope.extendBrowserLocation = function ( options ) {
    var params = _.extend( { }, $location.search( ), options );
    params = _.omitBy( params, function ( value ) {
      return _.isEmpty( value ) && !_.isBoolean( value ) && !_.isNumber( value );
    } );
    return "?" + $.param( params );
  };
  $scope.updateBrowserLocation = function ( options ) {
    options = options || { };
    if ( options.skipSetLocation ) { return; }
    var newParams = [];
    _.each( $scope.params, function ( value, param ) {
      // don't show default params in the URL
      if ( _.has( $scope.defaultParams, param ) && value === $scope.defaultParams[param] ) {
        return;
      }
      // assess view and subview params below
      if ( param === "view" || param === "subview" ) { return; }
      newParams.push( [param, value] );
    } );
    if ( $scope.currentView !== $scope.defaultView ) {
      newParams.push( ["view", $scope.currentView] );
      if ( $scope.drawing.pendingDrawing ) {
        $scope.clearBoundary( );
      }
    }
    if ( $scope.currentSubview !== $scope.defaultSubview ) {
      newParams.push( ["subview", $scope.currentSubview] );
    }
    // keep param order consistent
    newParams = _.sortBy( newParams, function ( arr ) {
      return arr[0];
    } );
    // default to initial state
    var currentState = { };
    var currentSearch = { };
    if ( !_.isEmpty( newParams ) ) {
      var urlParams = ObservationsFactory.processParams(
        _.fromPairs( newParams ),
        $scope.possibleFields
      );
      urlParams = _.mapValues( urlParams, function ( v, k ) {
        // arrays turned to comma-delimited lists for URLs
        if ( Array.isArray( v ) ) { return v.join( "," ); }
        // allow `photos=any` when the default value of true is changed
        if ( $scope.defaultParams[k] === true && v !== true ) { v = "any"; }
        return v;
      } );
      // never show `viewer_id` in the browser location
      delete urlParams.viewer_id;
      // add to the state a few params that don't appear in the URL
      var stateParams = _.extend( { }, urlParams, {
        dateType: $scope.params.dateType,
        createdDateType: $scope.params.createdDateType
      } );
      // prepare current settings to store in browser state history
      currentState = {
        params: stateParams,
        selectedPlace: JSON.stringify( $scope.selectedPlace ),
        selectedTaxon: JSON.stringify( $scope.selectedTaxon ),
        mapBounds: $scope.mapBounds
      };
      currentSearch = urlParams;
    }

    $scope.numFiltersSet = _.keys( currentSearch ).length;
    var skippableParams = ["view", "subview", "taxon_id", "place_id",
      "swlat", "swlng", "nelat", "nelng", "page"];
    // eslint-disable-next-line no-plusplus
    for ( var i = skippableParams.length - 1; i >= 0; i -= 1 ) {
      if ( currentSearch[skippableParams[i]] ) {
        $scope.numFiltersSet -= 1;
      }
    }
    if ( currentSearch.iconic_taxa && currentSearch.iconic_taxa.split( "," ).length > 1 ) {
      $scope.numFiltersSet += currentSearch.iconic_taxa.split( "," ).length - 1;
    }

    if ( options.browserStateOnly ) {
      $scope.initialBrowserState = currentState;
    } else {
      $location.state( currentState );
      if ( options.replace ) {
        $location.search( currentSearch ).replace( );
      } else {
        $location.search( currentSearch );
      }
    }
  };
  $scope.viewing = function ( view, subview ) {
    if ( subview ) {
      if ( view === $scope.currentView && subview === $scope.currentSubview ) {
        return true;
      }
    } else if ( view === $scope.currentView ) {
      return true;
    }
    return false;
  };
  $scope.changeView = function ( newView, newSubview, options ) {
    if ( newView !== $scope.currentView || newSubview !== $scope.currentSubview ) {
      $scope.currentView = newView;
      // note: subview is being preserved on view changes
      if ( newSubview ) {
        $scope.currentSubview = newSubview;
        updateSession( { prefers_observations_search_subview: newSubview } );
      }
      $scope.updateBrowserLocation( options );
    }
  };
  $scope.searchingStopped = function ( ) {
    if ( !$scope.pagination ) { return false; }
    return $scope.pagination.stopped && !$scope.pagination.searching;
  };
  $scope.noObservations = function ( ) {
    if ( !$scope.searchingStopped( ) ) { return false; }
    return $scope.observations.length === 0;
  };
  $scope.noTaxa = function ( ) {
    if ( !$scope.searchingStopped( ) ) { return false; }
    return $scope.taxa.length === 0;
  };
  $scope.noIdentifiers = function ( ) {
    if ( !$scope.searchingStopped( ) ) { return false; }
    return $scope.identifiers.length === 0;
  };
  $scope.noObservers = function ( ) {
    if ( !$scope.searchingStopped( ) ) { return false; }
    return $scope.observers.length === 0;
  };
  $scope.showPages = function ( ) {
    if ( !$scope.searchingStopped( ) ) { return false; }
    return $scope.pagination.total > $scope.pagination.perPage;
  };
  $scope.positionDragDrawingIcon = function ( shape, options ) {
    if ( !$scope.drawing.dragIcon || !_.isFunction( shape.getBounds )
      || !$scope.map || !$scope.map.getProjection( ) ) {
      return;
    }
    var isCircle = !!shape.setCenter;
    var shapeCenter = shape.getBounds( ).getCenter( );
    var sw = shape.getBounds( ).getSouthWest( );
    var ne = shape.getBounds( ).getNorthEast( );
    var bottomCenter = {
      lat: sw.lat( ),
      lng: shapeCenter.lng( )
    };
    var point = $scope.latLng2Point( bottomCenter, $scope.map );
    var dragIconLatLng = $scope.point2LatLng( {
      x: point.x, y: point.y + $scope.dragIconOffset
    }, $scope.map );
    if ( isCircle ) {
      $scope.dragCircleDeltaInKm = $scope.getHaversineDistanceInKm(
        { lat: sw.lat( ), lng: bottomCenter.lng },
        { lat: shapeCenter.lat( ), lng: shapeCenter.lng( ) }
      );
    } else {
      var nePoint = $scope.latLng2Point( ne, $scope.map );
      $scope.dragRectDeltaXInPx = nePoint.x - point.x;
      $scope.dragRectDeltaYInPx = point.y - nePoint.y;
    }
    if ( options && options.reappear ) {
      $scope.drawing.dragIcon.setVisible( false );
      $scope.drawing.dragIcon.setPosition( dragIconLatLng );
      setTimeout( function ( ) {
        $scope.drawing.dragIcon.setVisible( true );
      }, 500 );
    } else {
      $scope.drawing.dragIcon.setPosition( dragIconLatLng );
    }
  };
  $scope.positionDrawing = function ( dragIconPosition, shape ) {
    var isCircle = !!shape.setCenter;
    var dragIconPoint = $scope.latLng2Point( dragIconPosition, $scope.map );
    if ( isCircle ) {
      // locate bottom of where new circle should be drawn. This should be
      // placed exactly {$scope.dragIconOffset}px above the drag icon,
      // regardless of current latitude
      var circleBottomLatLng = $scope.point2LatLng( {
        x: dragIconPoint.x, y: dragIconPoint.y - $scope.dragIconOffset
      }, $scope.map );
      var circleBottomLatRadians = $scope.toRadians( circleBottomLatLng.lat( ) );
      var newCircleCenterLatRadians = Math.asin( (
        Math.sin( circleBottomLatRadians )
          * Math.cos( $scope.dragCircleDeltaInKm / $scope.earthRadiusInKm )
      ) + (
        Math.cos( circleBottomLatRadians )
          * Math.sin( $scope.dragCircleDeltaInKm / $scope.earthRadiusInKm )
      ) );
      shape.setCenter( {
        lat: $scope.toDegrees( newCircleCenterLatRadians ),
        lng: dragIconPosition.lng( )
      } );
    } else {
      var ne = $scope.point2LatLng( {
        x: dragIconPoint.x + $scope.dragRectDeltaXInPx,
        y: dragIconPoint.y - $scope.dragRectDeltaYInPx - $scope.dragIconOffset
      }, $scope.map );
      var sw = $scope.point2LatLng( {
        x: dragIconPoint.x - $scope.dragRectDeltaXInPx,
        y: dragIconPoint.y - $scope.dragIconOffset
      }, $scope.map );
      var bounds = new google.maps.LatLngBounds( sw, ne );
      shape.setBounds( bounds );
    }
  };
  $scope.searchAndUpdateStats = function ( options ) {
    if ( $scope.searchDisabled ) { return; }
    $scope.params.page = $scope.params.page || 1;
    $scope.pagingInitialized = false;
    $scope.pagination = $scope.pagination || { };
    $scope.pagination.page = $scope.params.page;
    $scope.pagination.section = 1;
    $scope.pagination.maxSections = 4;
    $scope.pagination.perSection = 24;
    $scope.pagination.perPage = $scope.pagination.maxSections * $scope.pagination.perSection;
    $scope.pagination.searching = true;
    $scope.pagination.stopped = false;
    $scope.identifiersPagination = $scope.identifiersPagination || { };
    $scope.identifiersPagination.searching = true;
    $scope.observersPagination = $scope.observersPagination || { };
    $scope.observersPagination.searching = true;
    $scope.speciesPagination = $scope.speciesPagination || { };
    $scope.speciesPagination.page = 1;
    $scope.speciesPagination.perPage = 50;
    $scope.speciesPagination.searching = true;
    $scope.speciesPagination.stopped = false;
    // important to note we're not resetting scope.pagination.total to 0,
    // as that would cause ui.bootstrap to jump back to page 1
    $scope.numberTaxaShown = 15;
    $scope.numberIdentifiersShown = 15;
    $scope.numberObserversShown = 15;
    $scope.observersSort = "-observationCount";
    options = options || { };
    $scope.updateBrowserLocation( options );
    $scope.observations = [];
    $scope.taxa = [];
    $scope.identifiers = [];
    $scope.observers = [];
    $scope.resetStats( );
    var processedParamsWithoutLocale = ObservationsFactory.processParamsForAPI(
      _.extend( { }, $scope.params ),
      $scope.possibleFields
    );
    var processedParams = _.extend(
      { },
      processedParamsWithoutLocale,
      iNaturalist.localeParams( )
    );
    // recording there was some location in the search. That will be used
    // to hide the `Redo Search` button until the map moves
    if ( processedParams.place_id || processedParams.swlat ) {
      $scope.drawing.disabled = true;
    }
    if ( processedParams.place_id ) {
      $scope.disableRedoSearch = false;
    }
    if ( processedParams.place_id ) {
      $scope.removeDragIcon( );
      if ( $scope.drawing.pendingDrawing ) {
        $scope.drawing.pendingDrawing = null;
      }
    }
    var isDefaultSearch = _.isEqual( $scope.defaultProcessedParams, processedParamsWithoutLocale );
    if ( isDefaultSearch ) {
      processedParams.ttl = 3600;
    }
    var statsParams = _.omit( processedParams, ["order_by", "order", "page"] );
    var searchParams = _.extend( { }, processedParams, {
      page: $scope.apiPage( ) || 1,
      per_page: $scope.pagination.perSection
    } );
    // Only request the bounds if this isn't a default search
    if (
      ( options.browserStateOnly || !$scope.mapLayersInitialized )
      && !isDefaultSearch
    ) {
      searchParams.return_bounds = true;
    }
    // prevent slow searches from overwriting current results
    var thisSearchTime = new Date( ).getTime( );
    $scope.lastSearchTime = thisSearchTime;
    ObservationsFactory.search( searchParams ).then( function ( response ) {
      if ( $scope.lastSearchTime !== thisSearchTime ) { return; }
      // this is an initial search, and not the default no-params search,
      // and we have bounds of the results, so focus the map on the results
      if (
        response.data.total_bounds
        && ( options.browserStateOnly || !$scope.mapLayersInitialized )
        && !isDefaultSearch
        && !$scope.params.swlat
      ) {
        var bounds = response.data.total_bounds;
        var swlat = bounds.swlat;
        var swlng = bounds.swlng;
        var nelat = bounds.nelat;
        var nelng = bounds.nelng;
        if ( swlat < -80 ) { swlat = -80; }
        if ( swlng < -179.9 ) { swlng = -179.9; }
        if ( nelat > 80 ) { nelat = 80; }
        if ( nelng > 179.9 ) { nelng = 179.9; }
        $scope.mapBounds = {
          swlat: swlat,
          swlng: swlng,
          nelat: nelat,
          nelng: nelng
        };
        $rootScope.$emit( "alignMap" );
      }

      $scope.pagination.searching = false;
      thisSearchTime = new Date( ).getTime( );
      $scope.lastSearchTime = thisSearchTime;
      $scope.totalObservations = response.data.total_results;
      $scope.pagination.total = response.data.total_results;
      if ( $scope.pagination.total === 0 ) {
        $scope.totalSpecies = 0;
        $scope.totalIdentifiers = 0;
        $scope.totalObservers = 0;
        $scope.pagination.stopped = true;
        return;
      }
      $scope.observations = ObservationsFactory.responseToInstances( response );
      $scope.statsParams = statsParams;
      $scope.statsParamsOnlyCount = _.extend( { }, statsParams, { per_page: 0 } );

      var dataLoadPromises = [$scope.loadSpecies];
      if ( $scope.currentView === "identifiers" ) {
        dataLoadPromises.unshift( $scope.loadIdentifiers );
      } else {
        dataLoadPromises.push( $scope.loadIdentifiers );
      }
      if ( $scope.currentView === "observers" ) {
        dataLoadPromises.unshift( $scope.loadObservers );
      } else {
        dataLoadPromises.push( $scope.loadObservers );
      }
      dataLoadPromises.reduce( function ( p, promise ) {
        return p.then( function ( ) { return promise( thisSearchTime ); } );
      }, Promise.resolve( ) );
    } );
  };

  $scope.loadSpecies = function ( searchTime ) {
    var speciesParams = _.extend( { }, $scope.statsParams, {
      per_page: $scope.speciesPagination.perPage
    } );
    return ObservationsFactory.speciesCounts( speciesParams )
      .then( function ( response ) {
        if ( $scope.lastSearchTime !== searchTime ) { return; }
        $scope.totalSpecies = response.data.total_results;
        $scope.taxa = _.map( response.data.results, function ( r ) {
          var t = new iNatModels.Taxon( r.taxon );
          t.resultCount = r.count;
          return t;
        } );
        $scope.speciesPagination.searching = false;
      } );
  };

  $scope.loadIdentifiers = function ( searchTime ) {
    return ObservationsFactory
      .identifiers( $scope.currentView === "identifiers"
        ? $scope.statsParams
        : $scope.statsParamsOnlyCount )
      .then( function ( response ) {
        if ( $scope.lastSearchTime !== searchTime ) { return; }
        $scope.totalIdentifiers = response.data.total_results;
        $scope.identifiers = _.map( response.data.results, function ( r ) {
          var u = new iNatModels.User( r.user );
          u.resultCount = r.count;
          return u;
        } );
        $scope.identifiersPagination.searching = false;
      } );
  };

  $scope.loadObservers = function ( searchTime ) {
    return ObservationsFactory
      .observers( $scope.currentView === "observers"
        ? $scope.statsParams
        : $scope.statsParamsOnlyCount )
      .then( function ( response ) {
        if ( $scope.lastSearchTime !== searchTime ) { return; }
        $scope.totalObservers = response.data.total_results;
        $scope.observers = _.map( response.data.results, function ( r ) {
          var u = new iNatModels.User( r.user );
          u.observationCount = r.observation_count;
          u.speciesCount = r.species_count;
          return u;
        } );
        $scope.observersPagination.searching = false;
      } );
  };

  $scope.showMoreIdentifiers = function ( ) {
    $scope.identifiersPagination = $scope.identifiersPagination || { };
    if ( $scope.totalIdentifiers > 0 && _.isEmpty( $scope.identifiers ) ) {
      if ( $scope.identifiersPagination.searching === true ) { return; }
      $scope.identifiersPagination.searching = true;
      ObservationsFactory
        .identifiers( _.extend( { }, $scope.statsParams, { no_total_hits: true } ) )
        .then( function ( response ) {
          $scope.identifiers = _.map( response.data.results, function ( r ) {
            var u = new iNatModels.User( r.user );
            u.resultCount = r.count;
            return u;
          } );
          $scope.identifiersPagination.searching = false;
        } );
      return;
    }
    // simple "pagination" of results already fetched, so we're not
    // rendering too many DOM elements, which need images fetched
    $scope.numberIdentifiersShown += 20;
  };

  $scope.showMoreObservers = function ( ) {
    $scope.observersPagination = $scope.observersPagination || { };
    if ( $scope.totalObservers > 0 && _.isEmpty( $scope.observers ) ) {
      if ( $scope.observersPagination.searching === true ) { return; }
      $scope.observersPagination.searching = true;
      ObservationsFactory
        .observers( _.extend( { }, $scope.statsParams, { no_total_hits: true } ) )
        .then( function ( response ) {
          $scope.observers = _.map( response.data.results, function ( r ) {
            var u = new iNatModels.User( r.user );
            u.observationCount = r.observation_count;
            u.speciesCount = r.species_count;
            return u;
          } );
          $scope.observersPagination.searching = false;
        } );
      return;
    }
    // simple "pagination" of results already fetched, so we're not
    // rendering too many DOM elements, which need images fetched
    $scope.numberObserversShown += 20;
  };

  $scope.showMoreTaxa = function ( ) {
    $scope.speciesPagination = $scope.speciesPagination || { };
    if ( !$scope.taxa || _.isEmpty( $scope.speciesPagination ) ) { return; }
    if ( $scope.speciesPagination.page >= 20
      || ( $scope.speciesPagination.page * $scope.speciesPagination.perPage )
        > $scope.totalSpecies ) {
      $scope.speciesPagination.stopped = true;
    }
    if ( $scope.speciesPagination.searching === true ) { return; }
    if ( $scope.speciesPagination.stopped === true ) { return; }
    $scope.speciesPagination.searching = true;
    $scope.speciesPagination.page += 1;

    var taxonParams = _.extend(
      { },
      $scope.statsParams,
      {
        page: $scope.speciesPagination.page,
        per_page: $scope.speciesPagination.perPage
      }
    );
    ObservationsFactory.speciesCounts( taxonParams ).then( function ( response ) {
      $scope.totalSpecies = response.data.total_results;
      $scope.taxa = $scope.taxa.concat( _.map( response.data.results, function ( r ) {
        var t = new iNatModels.Taxon( r.taxon );
        t.resultCount = r.count;
        return t;
      } ) );
      $scope.speciesPagination.searching = false;
    } );
  };
  $scope.apiPage = function ( ) {
    var page = ( ( $scope.pagination.page - 1 ) * $scope.pagination.maxSections )
      + $scope.pagination.section;
    return page || 1;
  };
  $scope.showMoreObservations = function ( ) {
    $scope.pagination = $scope.pagination || { };
    if ( !$scope.pagination.page ) { return; }
    if ( !$scope.observations ) { return; }
    if ( $scope.pagination.searching === true ) { return; }
    if ( $scope.pagination.stopped === true ) { return; }
    $scope.pagination.section += 1;
    $scope.pagination.searching = true;
    var processedParams = ObservationsFactory.processParamsForAPI(
      _.extend(
        { },
        $scope.params,
        iNaturalist.localeParams( ),
        {
          page: $scope.apiPage( ),
          per_page: $scope.pagination.perSection
        }
      ),
      $scope.possibleFields
    );
    var searchHasManyResults = $scope.pagination.total > 10000;
    if ( searchHasManyResults ) {
      processedParams.no_total_hits = true;
    }

    ObservationsFactory.search( processedParams ).then( function ( response ) {
      if ( ( ( response.data.total_results <= ( response.data.page * response.data.per_page ) )
        && !searchHasManyResults
      ) || ( $scope.pagination.section >= $scope.pagination.maxSections ) ) {
        $scope.pagination.stopped = true;
      }
      $scope.observations = $scope.observations.concat(
        ObservationsFactory.responseToInstances( response )
      );
      $scope.pagination.searching = false;
    } );
  };
  $scope.$watch( "pagination.page", function ( ) {
    if ( !$scope.pagingInitialized ) {
      $scope.pagingInitialized = true;
      return;
    }
    $anchorScroll( );
    $scope.skipParamChange = true;
    $scope.params.page = $scope.pagination.page;
    $scope.updateBrowserLocation( );
    $scope.observations = [];
    $scope.pagination.section = 0;
    $scope.pagination.stopped = false;
    $scope.showMoreObservations( );
  } );
  $scope.matchUrlState = function ( ) {
    var urlParams = $location.search( );
    if ( $scope.params.view && _.includes( $scope.possibleViews, $scope.params.view ) ) {
      $scope.currentView = urlParams.view;
    }
    if ( $scope.possibleSubviews.observations
      && _.includes( $scope.possibleSubviews.observations, $scope.params.subview ) ) {
      $scope.currentSubview = $scope.params.subview;
    }
    if ( urlParams.on ) {
      $scope.params.dateType = "exact";
    } else if ( urlParams.d1 || urlParams.d2 ) {
      $scope.params.dateType = "range";
    } else if ( urlParams.month ) {
      $scope.params.dateType = "month";
    }
    if ( urlParams.created_on ) {
      $scope.params.createdDateType = "exact";
    } else if ( urlParams.created_d1 || urlParams.created_d2 ) {
      $scope.params.createdDateType = "range";
    }
    $scope.currentView = $scope.currentView || $scope.defaultView;
    $scope.currentSubview = $scope.currentSubview || $scope.defaultSubview;
    $scope.changeView( $scope.currentView, $scope.currentSubview, { skipSetLocation: true } );
    // once we set the views, the view params should be deleted
    delete $scope.params.view;
    delete $scope.params.subview;
    $scope.setObservationFields( );
  };
  $scope.showNearbyPlace = function ( place ) {
    $rootScope.$emit( "showNearbyPlace", place );
  };
  $scope.hideNearbyPlace = function ( place ) {
    $rootScope.$emit( "hideNearbyPlace", place );
  };
  $scope.filterByPlace = function ( place ) {
    $rootScope.$emit( "hideNearbyPlace" );
    $scope.selectedPlace = place;
    $scope.removeSelectedBounds( );
    $scope.updatePlaceAutocomplete( );
  };
  $scope.getDrawingManagerOptions = function ( shape ) {
    return _.extend( {
      drawingMode: $scope.shapeMap[shape].mode,
      drawingControl: false,
      markerOptions: {
        icon: ""
      },
      drawingControlOptions: {
        position: google.maps.ControlPosition.TOP_CENTER,
        drawingModes: [$scope.shapeMap[shape].mode]
      }
    }, $scope.shapeMap[shape].options );
  };
  $scope.drawBoundary = function ( shape ) {
    // here the user is unclicking a drawing button after it had been selected,
    // but nothing was drawn
    if ( $scope.drawing.pendingDrawing && $scope.drawing.pendingDrawing === shape ) {
      if ( $scope.drawing.currentShape ) {
        $scope.drawing.manager.setMap( null );
        $scope.drawing.disabled = false;
        $scope.drawing.pendingDrawing = null;
      } else {
        $scope.clearBoundary( );
      }
      return;
    }

    $scope.drawing.pendingDrawing = shape;
    $scope.drawing.disabled = true;
    if ( !$scope.drawing.currentShape ) {
      $rootScope.$emit( "hideNearbyPlace" );
    }
    $scope.drawing.manager.setOptions( $scope.getDrawingManagerOptions( shape ) );
    $scope.drawing.manager.setMap( $rootScope.map );
  };

  $scope.filterByBounds = function ( ) {
    $scope.params.lat = null;
    $scope.params.lng = null;
    $scope.params.radius = null;
    $scope.drawing.currentShape = "rectangle";
    $scope.drawing.disabled = true;
    $scope.drawing.pendingDrawing = null;
    if ( $scope.drawing.manager ) {
      $scope.drawing.manager.setMap( null );
    }
    $scope.removeDragIcon( );
    $rootScope.$emit( "hideNearbyPlace" );
    $scope.removeSelectedPlace( );
    $rootScope.$emit( "updateParamsForCurrentRect" );
    $scope.map.setZoom( $scope.map.getZoom( ) - 1 );
  };
  $scope.removeSelectedPlace = function ( ) {
    if ( $scope.selectedPlaceLayer ) {
      $scope.selectedPlaceLayer.setMap( null );
    }
    $scope.selectedPlace = null;
    $scope.selectedPlaceLayer = null;
    $scope.mapBounds = null;
  };
  $scope.clearPlaceSearch = function ( ) {
    $scope.removeSelectedPlace( );
    $scope.drawing.currentShape = null;
    $scope.drawing.disabled = false;
  };
  $scope.removeSelectedBounds = function ( ) {
    $scope.params.swlng = null;
    $scope.params.swlat = null;
    $scope.params.nelng = null;
    $scope.params.nelat = null;
    $scope.params.lat = null;
    $scope.params.lng = null;
    $scope.params.radius = null;
    $scope.mapBounds = null;
  };
  $scope.clearBoundary = function ( ) {
    $scope.drawing.manager.setMap( null );
    $scope.drawing.currentShape = null;
    $scope.drawing.disabled = false;
    $scope.drawing.pendingDrawing = null;
    $scope.removeDragIcon( );
    $scope.removeSelectedBounds( );
  };
  $scope.removeDragIcon = function ( ) {
    if ( $scope.drawing.dragIcon ) {
      $scope.drawing.dragIcon.setVisible( false );
    }
  };
  $scope.searchForNearbyPlaces = function ( ) {
    $rootScope.$emit( "searchForNearbyPlaces" );
  };
  $scope.orderBy = function ( order ) {
    if ( $scope.params.order_by === order ) {
      $scope.params.order = ( $scope.params.order === "asc" ? "desc" : "asc" );
    } else {
      $scope.params.order_by = order;
      $scope.params.order = "desc";
    }
  };
  $scope.setupFilterToggle = function ( ) {
    // I started using the default bootstrap dropdown to manage the filter opening,
    // but it assumes all clicks in the dropdown should close the dropdown, so I had
    // to not use the bootstrap javascript there and do it myself
    $( "#filter-container .dropdown-toggle" ).click( function ( ) {
      $( this ).parent( ).toggleClass( "open" );
      // Sooo hacky, but hard to get it to translate the SELECT element
      // before running the jquery ui code otherwise
      $( "#filters select[multiple]" ).not( ".multiselectified" ).multiselect( {
        minWidth: 150,
        checkAllText: I18n.t( "all" ),
        uncheckAllText: I18n.t( "none" ),
        open: function ( event ) {
          $scope.params.dateType = "month";
          $( event.target ).parents( "label:first" ).click( );
        }
      } );
      $( "#filters select[multiple]" ).not( ".multiselectified" ).addClass( "multiselectified" );
    } );
    // closing the filter box
    $( "body" ).on( "click", function ( e ) {
      if ( !$( "#filter-container" ).is( e.target )
          && $( "#filter-container" ).has( e.target ).length === 0
          && $( ".open" ).has( e.target ).length === 0
          && $( e.target ).parents( ".ui-autocomplete" ).length === 0
          && $( e.target ).parents( ".ui-datepicker" ).length === 0
          && $( e.target ).parents( ".ui-datepicker-header" ).length === 0
          && $( e.target ).parents( ".ui-multiselect-menu" ).length === 0
          && $( e.target ).parents( ".observation-field" ).length === 0
      ) {
        $( "#filter-container" ).removeClass( "open" );
      }
    } );
    // these buttons look better without a focus state
    $( ".btn.iconic-taxon" ).focus( function ( ) {
      $( this ).blur( );
    } );
  };
  $scope.setupDatepicker = function ( ) {
    $( ".date-picker" ).datepicker( {
      yearRange: "c-100:" + ( new Date( ) ).getFullYear( ),
      maxDate: "+0d",
      constrainInput: false,
      firstDay: 0,
      changeFirstDay: false,
      changeMonth: true,
      changeYear: true,
      dateFormat: "yy-mm-dd",
      showTimezone: false,
      closeText: I18n.t( "date_picker.closeText" ),
      currentText: I18n.t( "date_picker.currentText" ),
      prevText: I18n.t( "date_picker.prevText" ),
      nextText: I18n.t( "date_picker.nextText" ),
      montNames: _.compact( _.values( I18n.t( "date.month_names" ) ) ),
      monthNamesShort: _.compact( _.values( I18n.t( "date.abbr_month_names" ) ) ),
      dayNames: _.compact( _.values( I18n.t( "date.day_names" ) ) ),
      dayNamesShort: _.compact( _.values( I18n.t( "date.abbr_day_names" ) ) ),
      dayNamesMin: _.compact( _.values( I18n.t( "date.day_names_min" ) ) )
    } );
  };
  $scope.setupPlaceSearchbox = function ( ) {
    if ( !googleMapsIsLoaded( ) ) return;
    // only search for "geocode" types, not businesses
    $scope.placeSearchBox = new google.maps.places.Autocomplete(
      document.getElementById( "place_name" ),
      { types: ["geocode"] }
    );
    $scope.placeSearchBox.addListener( "place_changed", function ( ) {
      var place = $scope.placeSearchBox.getPlace( );
      if ( place && place.geometry ) {
        $scope.setSearchedPlace( place );
        return;
      }
      // there was no selected place, so query with the current input value
      $scope.searchPlaceAutocompleteService( );
    } );
    $scope.placeAutocompleteService = new google.maps.places.AutocompleteService( );
  };
  $scope.searchPlaceAutocompleteService = function ( ) {
    var q = $( "#place_name" ).val( );
    if ( !q ) { return; }
    // query the autocomplete service for the text in the search input
    $scope.placeAutocompleteService.getQueryPredictions(
      { input: q },
      function ( predictions, status ) {
        if ( status !== google.maps.places.PlacesServiceStatus.OK
         || predictions.length === 0 || !predictions[0].place_id ) { return; }
        // now that we have the result, we need to query the PlacesService
        // for the geometry. That service needs to be associated with an
        // element, so use the map if we can, otherwise make one up
        var e = $scope.viewing( "observations", "map" ) ? $( "#map" ).data( "taxonMap" )
          : document.createElement( "div" );
        var s = new google.maps.places.PlacesService( e );
        s.getDetails( { placeId: predictions[0].place_id }, function ( place ) {
          if ( status !== google.maps.places.PlacesServiceStatus.OK ) { return; }
          // use the details of the fetched place
          $scope.setSearchedPlace( place );
        } );
      }
    );
  };
  $scope.setSearchedPlace = function ( place ) {
    if ( !place || !place.geometry ) { return; }
    $scope.searchedPlace = place;
    $scope.focusOnSearchedPlace( );
    if ( !$scope.viewing( "observations", "map" ) ) {
      $scope.mapNeedsAligning = true;
    }
  };
  $scope.focusOnSearchedPlace = function ( ) {
    if ( $scope.searchedPlace ) {
      // setting a timer for automatching the searched place to a known place
      $scope.placeLastSearched = new Date( ).getTime( );
      $scope.autoPlaceSelect = true;
      $scope.mapBounds = null;
      var location = $scope.searchedPlace.geometry.location;
      var bounds;
      if ( $scope.searchedPlace.geometry.viewport ) {
        var viewport = $scope.searchedPlace.geometry.viewport;
        bounds = googleMapsBoundsToObject( viewport );
      } else {
        // use some bounds which equate roughly to zoom level 15
        bounds = {
          swlat: location.lat( ) - 0.01,
          swlng: location.lng( ) - 0.02,
          nelat: location.lat( ) + 0.01,
          nelng: location.lng( ) + 0.02
        };
      }
      // if the searched place is specific enough to have an address
      if ( $scope.searchedPlace.adr_address
        && $scope.searchedPlace.adr_address.match( /address/ ) ) {
        // align the map straight away w/o looking for a best place to choose
        $scope.mapBounds = bounds;
        $rootScope.$emit( "updateParamsForCurrentRect" );
        $rootScope.$emit( "alignMap" );
        $scope.$apply( );
      } else {
        var name = ( _.isObject( $scope.searchedPlace )
          ? $scope.searchedPlace.name : $scope.searchedPlace ).toLowerCase( );
        var options = {
          bounds: bounds,
          params: {
            per_page: 1,
            name: name,
            lat: location.lat( ),
            lng: location.lng( )
          }
        };
        $scope.drawing.currentShape = null;
        $scope.drawing.manager.setMap( null );
        $scope.drawing.currentShape = null;
        $scope.drawing.disabled = false;
        $scope.drawing.pendingDrawing = null;
        $scope.removeDragIcon( );
        $scope.removeSelectedBounds( );
        // search for a best nearby place with a similar name
        $rootScope.$emit( "searchForNearbyPlaces", options, function ( response ) {
          if ( !response || !response.data || !response.data.results ) {
            $rootScope.$emit( "alignMap" );
            return
          }
          if ( response.data.results.standard.length > 0 ) {
            $scope.filterByPlace( response.data.results.standard[0] );
          } else if ( response.data.results.community.length > 0 ) {
            $scope.filterByPlace( response.data.results.community[0] );
          } else {
            $scope.mapBounds = bounds;
            $rootScope.$emit( "updateParamsForCurrentRect" );
            $rootScope.$emit( "alignMap" );
          }
        } );
      }
    } else {
      // no searched place yet, so try searching with place input text
      $scope.searchPlaceAutocompleteService( );
    }
  };
  // when the place search input changes, delete the stored searched place
  $scope.$watch( "placeSearch", function ( ) {
    $scope.searchedPlace = null;
  } );
  $scope.setupTaxonAutocomplete = function ( ) {
    $( "#filters input[name='taxon_name']" ).taxonAutocomplete( {
      resetOnChange: false,
      bootstrapClear: true,
      searchExternal: false,
      idEl: $( "#filters input[name='taxon_id']" ),
      afterSelect: function ( result ) {
        $scope.selectedTaxon = result.item;
        $scope.params.taxon_id = result.item.id;
        $scope.searchAndUpdateStats( );
      },
      afterUnselect: function ( ) {
        if ( $scope.params.taxon_id !== null ) {
          $scope.selectedTaxon = null;
          $scope.params.taxon_id = null;
          $scope.searchAndUpdateStats( );
        }
      }
    } );
  };
  $scope.updateTaxonAutocomplete = function ( ) {
    if ( $scope.selectedTaxon ) {
      $( "input[name='taxon_name']" ).trigger( "assignSelection", $scope.selectedTaxon );
    } else {
      $( "#filters input[name='taxon_name']" ).trigger( "search" );
    }
  };
  $scope.setupInatPlaceAutocomplete = function ( ) {
    $( "input[name='inat_place_name']" ).placeAutocomplete( {
      resetOnChange: false,
      bootstrapClear: true,
      idEl: $( "#filters input[name='place_id']" ),
      afterSelect: function ( result ) {
        $scope.filterByPlace( result.item );
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      },
      afterUnselect: function ( ) {
        $scope.removeSelectedPlace( );
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      }
    } );
  };
  $scope.updatePlaceAutocomplete = function ( ) {
    if ( $scope.selectedPlace ) {
      $scope.selectedPlace.title = $scope.selectedPlace.display_name;
      $( "input[name='inat_place_name']" )
        .trigger( "assignSelection", $scope.selectedPlace );
    } else {
      $( "#filters input[name='inat_place_name']" ).trigger( "search" );
    }
  };
  $scope.setupUserAutocomplete = function ( ) {
    $( "input[name='user_name']" ).userAutocomplete( {
      resetOnChange: false,
      bootstrapClear: true,
      idEl: $( "#filters input[name='user_id']" ),
      afterSelect: function ( result ) {
        $scope.params.user_id = result.item.login;
        $scope.params.spam = null;
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      },
      afterUnselect: function ( ) {
        $scope.params.user_id = null;
        $scope.params.spam = false;
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      }
    } );
    $scope.updateUserAutocomplete( );
  };
  $scope.updateUserAutocomplete = function ( ) {
    if ( $scope.params.user_id ) {
      $scope.params.spam = null;
      $( "input[name='user_name']" )
        .trigger(
          "assignSelection",
          { id: $scope.params.user_id, title: $scope.params.user_id }
        );
    } else {
      $scope.params.spam = false;
      $( "#filters input[name='user_name']" ).trigger( "search" );
    }
  };
  $scope.setupProjectAutocomplete = function ( ) {
    $( "input[name='project_name']" ).projectAutocomplete( {
      resetOnChange: false,
      bootstrapClear: true,
      idEl: $( "#filters input[name='project_id']" ),
      afterSelect: function ( result ) {
        $scope.params.project_id = result.item.slug;
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      },
      afterUnselect: function ( ) {
        $scope.params.project_id = null;
        if ( !$scope.$$phase ) { $scope.$digest( ); }
      }
    } );
    $scope.updateProjectAutocomplete( );
  };
  $scope.updateProjectAutocomplete = function ( ) {
    if ( $scope.params.project_id ) {
      $( "input[name='project_name']" )
        .trigger(
          "assignSelection",
          { id: $scope.params.project_id, title: $scope.params.project_id }
        );
    } else {
      $( "#filters input[name='project_name']" ).trigger( "search" );
    }
  };
  $scope.setupBrowserStateBehavior = function ( ) {
    window.onpopstate = function ( event ) {
      if ( $scope.drawing.currentShape ) {
        $scope.removeDragIcon( );
        $scope.$digest( );
      }
      var state = _.extend( { }, event.state || $scope.initialBrowserState );
      var previousParams = _.extend( { }, $scope.defaultParams, state.params );
      // needed to serialize some objects for storing in browser state
      // so now turn them back into object instances for comparison
      if ( state.selectedTaxon ) {
        state.selectedTaxon = new iNatModels.Taxon( JSON.parse( state.selectedTaxon ) );
      }
      if ( state.selectedPlace ) {
        state.selectedPlace = new iNatModels.Place( JSON.parse( state.selectedPlace ) );
      }
      // we could set place and taxon below, and that should not run searches
      $scope.searchDisabled = true;
      // restore the bounds we had to store as JSON
      if ( state.selectedPlace !== $scope.selectedPlace ) {
        $scope.filterByPlace( state.selectedPlace );
      }
      if ( state.mapBounds ) {
        $scope.mapBounds = {
          swlat: state.mapBounds.south,
          swlng: state.mapBounds.west,
          nelat: state.mapBounds.north,
          nelng: state.mapBounds.east
        };
      } else { $scope.mapBounds = null; }
      if ( state.selectedTaxon !== $scope.selectedTaxon ) {
        $scope.selectedTaxon = state.selectedTaxon;
        $scope.updateTaxonAutocomplete( );
      } else if ( state.params && state.params.taxon_id !== $scope.params.taxon_id ) {
        // useful for selecting a taxon from the observations grid view
        $scope.params.taxon_id = state.params.taxon_id;
        $scope.initializeTaxonParams( );
      }
      var previousProcessedParams = ObservationsFactory.processParamsForAPI(
        previousParams,
        $scope.possibleFields
      );
      delete previousProcessedParams.view;
      delete previousProcessedParams.subview;
      // restoring state of iconic taxa filters, (e.g { Chromista: true })
      if ( previousParams.iconic_taxa ) {
        previousParams.iconic_taxa_hash = _.fromPairs( _.map(
          previousParams.iconic_taxa.split( "," ),
          function ( n ) { return [n, true]; }
        ) );
      }
      $scope.searchDisabled = false;
      if ( !_.isEqual( $scope.processedParams, previousProcessedParams ) ) {
        $scope.goingBack = true;
        $scope.alignMapOnSearch = true;
        $scope.params = previousParams;
      }
      // make sure we don't set the location again when going back in history
      $scope.changeView(
        previousParams.view || $scope.defaultView,
        previousParams.subview || $scope.defaultSubview,
        { skipSetLocation: true }
      );
      $scope.setObservationFields( );
      if ( !$scope.$$phase ) { $scope.$digest( ); }
    };
  };
  $scope.determineFieldNames = function ( ) {
    _.map( $( "#filters input,select" ), function ( input ) {
      var name = $( input ).attr( "ng-model" ) || input.name;
      name = name.replace( "params.", "" );
      $scope.possibleFields.push( name );
    } );
    $scope.defaultProcessedParams = ObservationsFactory.processParamsForAPI(
      $scope.defaultParams,
      $scope.possibleFields
    );
  };
  $scope.paramsForUrl = function ( options ) {
    options = options || { };
    var urlParams = _.extend( { }, $scope.params );
    if ( urlParams.month && !Array.isArray( urlParams.month ) ) {
      urlParams.month = urlParams.month.split( "," );
    }
    urlParams.iconic_taxa = _.keys( urlParams.iconic_taxa_hash );
    if ( options.convertProjectsParam && urlParams.project_id ) {
      urlParams.projects = urlParams.project_id;
      delete urlParams.project_id;
    }
    // override `fields:` params with already processed observationFields, so
    // value is left undefined and not set to `true` when searching fields w/o values
    _.each( urlParams.observationFields, function ( v, k ) {
      urlParams[k] = v;
    } );
    delete urlParams.iconic_taxa_hash;
    delete urlParams.order;
    delete urlParams.order_by;
    delete urlParams.dateType;
    delete urlParams.createdDateType;
    delete urlParams.view;
    delete urlParams.subview;
    delete urlParams.viewer_id;
    delete urlParams.observationFields;
    return $.param( urlParams );
  };
  $scope.showInfowindow = function ( o ) {
    $rootScope.$emit( "showInfowindow", o );
  };
  $scope.hideInfowindow = function ( ) {
    $rootScope.$emit( "hideInfowindow" );
  };
  $scope.toggleShowViewerObservations = function ( ) {
    if ( !CURRENT_USER ) { return; }
    if ( $scope.params.user_id === CURRENT_USER.id
      || $scope.params.user_id === CURRENT_USER.login
    ) {
      $scope.params.user_id = null;
    } else {
      $scope.params.user_id = CURRENT_USER.login;
    }
  };
  $scope.canShowObservationFields = function ( ) {
    return ( $scope.params.observationFields && _.size( $scope.params.observationFields ) > 0 );
  };
  $scope.setObservationFields = function ( ) {
    var urlParams = $location.search( );
    // Put the URL params that correspond to observation fields in their own part of the scope
    // If there's a more readable way to perform this simple task, please let me know.
    $scope.params.observationFields = _.reduce( urlParams, function ( memo, v, k ) {
      if ( k.match( /(\w+):(\w+)/ ) ) {
        // true represents a key with no value, so leave value undefined
        k = decodeURIComponent( k ).replace( /(%20|\+)/g, " " );
        if ( _.isString( v ) ) { v = v.replace( /(%20|\+)/g, " " ); }
        memo[k] = ( v === true ) ? undefined : v;
      }
      return memo;
    }, { } );
  };
  $scope.removeObservationField = function ( field ) {
    if ( !$scope.params.observationFields ) {
      return;
    }
    if ( !_.has( $scope.params.observationFields, field ) ) {
      return;
    }
    delete $scope.params.observationFields[field];
  };

  $scope.preInitialize( );
};

application.controller( "MapController", ["ObservationsFactory", "PlacesFactory", "shared", "$scope", "$rootScope",
  function ( ObservationsFactory, PlacesFactory, shared, $scope, $rootScope ) {
    MapController( ObservationsFactory, PlacesFactory, shared, $scope, $rootScope );
    initializeMapController = function ( ) {
      $scope.dragIconMarker = new google.maps.Marker( {
        position: { lat: 0, lng: 0 },
        icon: {
          anchor: { x: 12, y: 12 },
          url: "<%= asset_path('drag-icon.svg') %>",
          scaledSize: { width: 24, height: 24 }
        },
        draggable: true,
        raiseOnDrag: false
      } );
      $scope.setupMap( );
    };
  }
] );

var MapController = function ( ObservationsFactory, PlacesFactory, shared, $scope, $rootScope ) {
  $rootScope.$on( "updateParamsForCurrentRect", function ( ) {
    $scope.updateParamsForCurrentRect( );
  } );
  $rootScope.$on( "offsetCenter", function ( event, left, up ) {
    // As of Google Maps v3.32, we need to wait for all animations to be
    // complete before performing these offset center calculations
    google.maps.event.addListenerOnce( $scope.map, "idle", function ( ) {
      shared.offsetCenter( { map: $scope.map, left: left, up: up }, function ( center ) {
        $scope.map.setCenter( center );
      } );
    } );
  } );
  $scope.setupMap = function ( ) {
    if ( $scope.map ) { return; }
    var defaultMapType = PREFERRED_MAP_TYPE || (
      googleMapsIsLoaded( ) && google.maps.MapTypeId.LIGHT
    );
    var taxonmapOptions = {
      placement: "observations-search",
      urlCoords: false,
      mapType: defaultMapType,
      showAllLayer: false,
      disableFullscreen: true,
      mapTypeControl: false,
      overlayMenu: false,
      zoomControl: false,
      infoWindowCallback: $scope.infoWindowCallback,
      minZoom: 2
    };
    if ( $scope.$parent.mapBounds ) {
      taxonmapOptions.minY = $scope.$parent.mapBounds.swlat;
      taxonmapOptions.minX = $scope.$parent.mapBounds.swlng;
      taxonmapOptions.maxY = $scope.$parent.mapBounds.nelat;
      taxonmapOptions.maxX = $scope.$parent.mapBounds.nelng;
    }
    $( "#map" ).taxonMap( taxonmapOptions );
    $scope.map = $( "#map" ).data( "taxonMap" );
    $rootScope.map = $scope.map;
    $scope.map.mapTypes.set(
      iNaturalist.Map.MapTypes.LIGHT_NO_LABELS,
      iNaturalist.Map.MapTypes.light_no_labels
    );
    $scope.map.mapTypes.set(
      iNaturalist.Map.MapTypes.LIGHT,
      iNaturalist.Map.MapTypes.light
    );
    // preparing the mapType, Labels, and Terrain buttons initial state
    // which can change depending on the user session/preferences
    if ( defaultMapType === google.maps.MapTypeId.SATELLITE
      || defaultMapType === google.maps.MapTypeId.HYBRID ) {
      $scope.$parent.mapType = "satellite";
    }
    if ( defaultMapType === iNaturalist.Map.MapTypes.LIGHT_NO_LABELS
      || defaultMapType === google.maps.MapTypeId.SATELLITE ) {
      $scope.$parent.mapLabels = false;
    }
    if ( defaultMapType === google.maps.MapTypeId.TERRAIN ) {
      $scope.$parent.mapTerrain = true;
    }
    // waiting a bit after creating the map to initialize the layers
    // to avoid issues with map aligning, letting the browser catch up
    setTimeout( function ( ) {
      if ( !$scope.mapLayersInitialized ) {
        $scope.setMapLayers( true );
        // more delays before enabling onMoves so setMapLayers
        // can finish aligning the map if it needs to
        setTimeout( function ( ) {
          $scope.map.addListener( "dragend", function ( ) {
            $scope.delayedOnMove( );
          } );
          $scope.map.addListener( "zoom_changed", function ( ) {
            if ( $scope.drawing.dragIcon && $scope.selectedPlaceLayer ) {
              $scope.positionDragDrawingIcon( $scope.selectedPlaceLayer, { reappear: true } );
            }
            $scope.delayedOnMove( );
            $scope.$parent.disableRedoSearch = $scope.map.getZoom( ) <= 2;
          } );
          google.maps.event.addListener( $scope.drawing.manager, "rectanglecomplete", function ( rectangle ) {
            $scope.drawing.pendingDrawing = null;
            if ( $scope.selectedPlace ) {
              $scope.$parent.selectedPlace = null;
            }
            if ( $scope.selectedPlaceLayer ) {
              $scope.selectedPlaceLayer.setMap( null );
            }
            $scope.drawing.currentShape = "rectangle";
            $scope.drawing.manager.setMap( null );
            $scope.selectedPlaceLayer = rectangle;
            $scope.refreshSelectedPlace( );
          } );
          google.maps.event.addListener( $scope.drawing.manager, "circlecomplete", function ( circle ) {
            $scope.drawing.pendingDrawing = null;
            if ( $scope.selectedPlace ) {
              $scope.$parent.selectedPlace = null;
            }
            if ( $scope.selectedPlaceLayer ) {
              $scope.selectedPlaceLayer.setMap( null );
            }
            if ( $scope.clearCircleIfInvalid( circle ) ) {
              return;
            }
            $scope.drawing.currentShape = "circle";
            $scope.drawing.manager.setMap( null );
            $scope.clearShapeBounds( );
            $scope.selectedPlaceLayer = circle;
            $scope.refreshSelectedPlace( );
          } );
        }, 500 );
        iNaturalist.Legend(
          $( "#map-legend-container" ).get( 0 ),
          $scope.map,
          { hideFeatured: true }
        );
      }
    }, 300 );
  };
  $scope.updateParamsForCurrentRect = function ( ) {
    var bounds = $scope.$parent.mapBounds;
    if ( !bounds && $scope.$parent.viewing( "observations", "map" ) && $scope.map ) {
      bounds = googleMapsBoundsToObject( $scope.map.getBounds( ) );
    }
    if ( !bounds ) {
      return;
    }
    $scope.$parent.mapBounds = bounds;
    $scope.setRectBounds( bounds );
  };
  $scope.clearShapeBounds = function ( ) {
    $scope.$parent.params.swlng = null;
    $scope.$parent.params.swlat = null;
    $scope.$parent.params.nelng = null;
    $scope.$parent.params.nelat = null;
    $scope.$parent.params.lat = null;
    $scope.$parent.params.lng = null;
    $scope.$parent.params.radius = null;
  };
  $scope.setRectBounds = function ( bounds ) {
    $scope.clearShapeBounds( );
    $scope.$parent.params.swlng = bounds.swlng;
    $scope.$parent.params.swlat = bounds.swlat;
    $scope.$parent.params.nelng = bounds.nelng;
    $scope.$parent.params.nelat = bounds.nelat;
    $scope.$parent.selectedPlace = null;
    $scope.$parent.selectedPlaceLayer = null;
  };
  $scope.setCircleBounds = function ( el ) {
    var point = el.getBounds( );
    var center = point.getCenter( );
    $scope.$parent.params.lng = center.lng( );
    $scope.$parent.params.lat = center.lat( );
    $scope.$parent.params.radius = el.getRadius( ) / 1000;
    $scope.$parent.selectedPlace = null;
    $scope.$parent.selectedPlaceLayer = null;
  };
  $rootScope.$on( "searchForNearbyPlaces", function ( event, options, callback ) {
    $scope.searchForNearbyPlaces( options, callback );
  } );
  $scope.searchForNearbyPlaces = function ( options, callback ) {
    if ( !googleMapsIsLoaded( ) ) return;
    var onMap = $scope.viewing( "observations", "map" );
    if ( $scope.$parent.placeSearchBox && $scope.map && onMap ) {
      $scope.$parent.placeSearchBox.setBounds( $scope.map.getBounds( ) );
    }
    options = options || { };
    options.params = options.params || { };
    if ( onMap ) {
      options.bounds = options.bounds || $scope.mapBounds || $scope.map.getBounds( );
    } else if ( $scope.mapBounds ) {
      options.bounds = options.bounds || $scope.mapBounds;
    }
    if ( options.bounds ) {
      options.params.swlat = options.bounds.swlat;
      options.params.swlng = options.bounds.swlng;
      options.params.nelat = options.bounds.nelat;
      options.params.nelng = options.bounds.nelng;
    }
    if ( !( options.params.lat && options.params.lng ) ) {
      // search a little left of center
      shared.offsetCenter(
        { map: ( onMap ? $scope.map : null ), left: -130, up: 0 },
        function ( center ) {
          if ( center ) {
            options.params.lat = center.lat( );
            options.params.lng = center.lng( );
          }
          $scope.nearbyPlaceSearch( options, callback );
        }
      );
    } else {
      $scope.nearbyPlaceSearch( options, callback );
    }
  };
  // if either the lat or lng is 0 after a user draws/resizes a circle, the user's drawn
  // some too large for DrawingManager to handle: it's no longer a self-contained shape
  // to the curvature of the earth. This just catches that scenario and cleans up
  $scope.clearCircleIfInvalid = function ( circle ) {
    var center = circle.getBounds( ).getCenter( );
    if ( center.lat( ) === 0 || center.lng( ) === 0 ) {
      circle.setMap( null );
      $scope.clearBoundary( );
      $scope.removeDragIcon( );
      $scope.$apply( );
      return true;
    }
    return false;
  };
  $scope.nearbyPlaceSearch = function ( options, callback ) {
    callback = callback || $scope.nearbyPlaceCallback;
    $scope.$parent.nearbyPlaces = null;
    $scope.$parent.searchingNearbyPlaces = true;
    PlacesFactory.nearby( options.params )
      .then( function ( response ) {
        $scope.$parent.searchingNearbyPlaces = false;
        callback( response );
      } );
  };
  $scope.nearbyPlaceCallback = function ( response ) {
    if ( !( response && response.data && response.data.results ) ) { return { }; }
    var nearbyPlaces = [];
    if ( response.data.total_results ) {
      nearbyPlaces = {
        standard: _.map( response.data.results.standard, function ( r ) {
          return new iNatModels.Place( r );
        } ),
        community: _.map( response.data.results.community, function ( r ) {
          return new iNatModels.Place( r );
        } )
      };
    }
    $scope.$parent.nearbyPlaces = nearbyPlaces;
    return { };
  };
  $rootScope.$on( "showNearbyPlace", function ( event, place ) {
    if ( $scope.nearbyPlaceLayer ) { $scope.nearbyPlaceLayer.setMap( null ); }
    $scope.nearbyPlaceLayer = null;
    $scope.nearbyPlaceLayer = new google.maps.Data( {
      style:
        _.extend( { }, $scope.boundaryBoxStyle, {
          strokeOpacity: 0.6,
          strokeWeight: 4
        } )
    } );
    var geojson = { type: "Feature", geometry: place.geometry_geojson };
    $scope.nearbyPlaceLayer.addGeoJson( geojson );
    $scope.nearbyPlaceLayer.setMap( $scope.map );
  } );
  $rootScope.$on( "hideNearbyPlace", function ( ) {
    if ( $scope.nearbyPlaceLayer ) { $scope.nearbyPlaceLayer.setMap( null ); }
    $scope.nearbyPlaceLayer = null;
  } );
  $rootScope.$on( "setMapLayers", function ( event, align ) {
    $scope.setMapLayers( align );
  } );
  $rootScope.$on( "alignMap", function ( ) {
    $scope.alignMap( );
  } );
  $rootScope.$on( "setMapType", function ( event, mapType, mapLabels, mapTerrain ) {
    if ( !$scope.map ) { return; }
    var mapTypeId;
    if ( mapType === "map" ) {
      if ( mapTerrain ) {
        mapTypeId = google.maps.MapTypeId.TERRAIN;
      } else {
        mapTypeId = mapLabels
          ? iNaturalist.Map.MapTypes.LIGHT
          : iNaturalist.Map.MapTypes.LIGHT_NO_LABELS;
      }
    } else {
      mapTypeId = mapLabels ? google.maps.MapTypeId.HYBRID : google.maps.MapTypeId.SATELLITE;
    }
    $scope.map.setMapTypeId( mapTypeId );
  } );
  $scope.delayedOnMove = function ( ) {
    // show the `Redo Search` button when the map moves
    $scope.enableRedoSearchInMapButton( );
    $scope.mapBounds = googleMapsBoundsToObject( $scope.map.getBounds( ) );
  };
  $scope.enableRedoSearchInMapButton = function ( ) {
    if ( $scope.$parent.disableRedoSearch ) {
      // only re-enable when not fully zoomed out
      $scope.$parent.disableRedoSearch = $scope.map.getZoom( ) <= 2;
      if ( !$scope.$parent.$$phase ) { $scope.$parent.$digest( ); }
    }
  };

  $scope.alignMap = function ( ) {
    // don't attempt aligning if we're not viewing the map
    if ( $scope.mapLayersInitialized && $scope.$parent.viewing( "observations", "map" ) ) {
      var bounds;
      if ( $scope.$parent.mapBounds ) {
        bounds = $scope.$parent.mapBounds;
        var swlat = bounds.swlat;
        var swlng = bounds.swlng;
        var nelat = bounds.nelat;
        var nelng = bounds.nelng;
        $scope.map.fitBounds( new google.maps.LatLngBounds(
          new google.maps.LatLng( swlat, swlng ),
          new google.maps.LatLng( nelat, nelng )
        ) );
        $rootScope.$emit( "offsetCenter", 130, 0 );
      } else if ( $scope.selectedPlaceLayer ) {
        // awkward check to see if it's a google.map.Data class. To determine the
        // appropriate zoom level for that requires examining the whole data structure
        if ( $scope.selectedPlaceLayer.forEach ) {
          bounds = new google.maps.LatLngBounds( );
          $scope.selectedPlaceLayer.forEach( function ( feature ) {
            shared.processPoints( feature.getGeometry( ), bounds.extend, bounds );
          } );
          $scope.map.fitBounds( bounds );
          if ( $scope.$parent.selectedPlace ) {
            // move the map to a little left of center
            $rootScope.$emit( "offsetCenter", 130, 0 );
          } else {
            $scope.map.setZoom( $scope.map.getZoom( ) + 1 );
          }
          if ( $scope.$parent.searchedPlace ) {
            $scope.$parent.searchedPlace.geometry.viewport = bounds;
          }
        } else {
          bounds = $scope.selectedPlaceLayer.getBounds( );
          $scope.map.fitBounds( bounds );
        }
        $scope.$parent.mapBounds = bounds;
      }
      $scope.$parent.mapNeedsAligning = false;
    }

    if ( $scope.map ) {
      $scope.initDragIcon( );
      $scope.$parent.disableRedoSearch = $scope.map.getZoom( ) <= 2;
    }
  };
  $rootScope.$on( "showInfowindow", function ( event, o ) {
    if ( !googleMapsIsLoaded( ) ) return;
    if ( $scope.snippetInfoWindowObservation
      && $scope.snippetInfoWindowObservation.id === o.id ) { return; }
    if ( $scope.snippetInfoWindow ) {
      $scope.snippetInfoWindow.close( );
    }
    $scope.snippetInfoWindowObservation = o;
    $scope.snippetInfoWindow = $scope.snippetInfoWindow
      || $scope.map.getInfoWindow( { disableAutoPan: true } );
    if ( !o.location ) {
      return;
    }
    var ll = o.location.split( "," );
    var latLng = new google.maps.LatLng( ll[0], ll[1] );
    var iwOpts = { };
    if ( $scope.map.zoom > 9 && o.geoprivacy !== "obscured" && !o.obscured ) {
      // if we're showing points and the marker isn't obscured then leave
      // a small margin under the infowindow so it show above the marker
      iwOpts.pixelOffset = new google.maps.Size( 0, -11 );
    } else {
      iwOpts.pixelOffset = new google.maps.Size( 0, 0 );
    }
    $scope.infoWindowCallback( $scope.map, $scope.snippetInfoWindow, latLng, o.id, iwOpts );
  } );
  $rootScope.$on( "hideInfowindow", function ( ) {
    $scope.snippetInfoWindowObservation = null;
    if ( $scope.snippetInfoWindow ) {
      $scope.snippetInfoWindow.close( );
    }
  } );
  $scope.infoWindowCallbackStartTime = null;
  // callback method when an observation is clicked on the map
  // fetch the observation details, and render the snippet template
  $scope.infoWindowCallback = function ( map, iw, latLng, observationID, options ) {
    map.infoWindowSetContent( iw, latLng, "<div class='infowindow loading'>"
      + I18n.t( "loading" ) + "</div>", options );
    var time = new Date( ).getTime( );
    $scope.infoWindowCallbackStartTime = time;
    ObservationsFactory.show( observationID, iNaturalist.localeParams( ) )
      .then( function ( response ) {
        var observations = ObservationsFactory.responseToInstances( response );
        if ( observations.length > 0 ) {
          $scope.infoWindowObservation = observations[0];
          // make sure the view is updated
          if ( !$scope.$parent.$$phase ) { $scope.$parent.$digest( ); }
          // delay this a bit so the view has time to update
          setTimeout( function ( ) {
            if ( $scope.infoWindowCallbackStartTime !== time ) { return; }
            map.infoWindowSetContent( iw, latLng, $( "#infoWindowSnippet" ).html( ), options );
          } );
        }
      } );
  };
  $scope.refreshSelectedPlace = function ( ) {
    if ( !$scope.selectedPlaceLayer ) {
      return;
    }
    if ( $scope.drawing.currentShape === "circle" ) {
      $scope.setCircleBounds( $scope.selectedPlaceLayer );
    } else {
      $scope.setRectBounds( googleMapsBoundsToObject( $scope.selectedPlaceLayer.getBounds( ) ) );
    }
    $scope.initDragIcon( );
    $scope.$apply( );
  };

  $scope.initDragIcon = function ( ) {
    if ( !$scope.selectedPlaceLayer || !$scope.selectedPlaceLayer.getBounds ) {
      return;
    }
    if ( $scope.drawing.dragIcon ) {
      $scope.removeDragIcon( );
    }

    $scope.dragIconMarker.setMap( $scope.map );
    $scope.dragIconMarker.setPosition( $scope.selectedPlaceLayer.getBounds( ).getCenter( ) );
    $scope.drawing.dragIcon = $scope.dragIconMarker;
    $scope.drawing.dragIcon.setVisible( true );

    $scope.positionDragDrawingIcon( $scope.selectedPlaceLayer );
    google.maps.event.addListener( $scope.drawing.dragIcon, "dragstart", function ( ) {
      $scope.drawing.dragging = true;
    } );
    google.maps.event.addListener( $scope.drawing.dragIcon, "drag", function ( dragIcon ) {
      $scope.positionDrawing( dragIcon.latLng, $scope.selectedPlaceLayer );
    } );
    google.maps.event.addListener( $scope.drawing.dragIcon, "dragend", function ( ) {
      $scope.drawing.dragging = false;
      if ( $scope.clearCircleIfInvalid( $scope.selectedPlaceLayer ) ) {
        return;
      }
      $scope.refreshSelectedPlace( );
    } );
  };

  $scope.setMapLayers = function ( align ) {
    if ( !$scope.map ) { return; }
    if ( !$scope.$parent.parametersInitialized ) { return; }
    window.inatTaxonMap.removeObservationLayers( $scope.map, { title: "Observations" } );
    var layerParams = ObservationsFactory.processParamsForAPI(
      $scope.params,
      $scope.possibleFields
    );
    layerParams.color = "iconic";
    if ( _.isEqual( $scope.$parent.defaultProcessedParams, layerParams ) ) {
      layerParams.ttl = 86400;
    }
    window.inatTaxonMap.addObservationLayers( $scope.map, {
      title: "Observations",
      mapStyle: "grid",
      observationLayers: [layerParams],
      infoWindowCallback: $scope.infoWindowCallback
    } );
    // fully remove any existing data layer
    if ( $scope.selectedPlaceLayer ) { $scope.selectedPlaceLayer.setMap( null ); }
    $scope.selectedPlaceLayer = null;

    // draw the polygon for the current place
    if ( $scope.$parent.selectedPlace ) {
      var c = { type: "Feature", geometry: $scope.$parent.selectedPlace.geometry_geojson };
      $scope.selectedPlaceLayer = new google.maps.Data( { style: $scope.boundaryBoxStyle } );
      $scope.selectedPlaceLayer.addGeoJson( c );
      $scope.selectedPlaceLayer.setMap( $scope.map );
    } else if ( $scope.params.swlat && $scope.params.swlng
      && $scope.params.nelat && $scope.params.nelng ) {
      if ( $scope.selectedPlaceLayer ) {
        $scope.removeSelectedPlace( );
      }
      // Redo Search in Map for a fully zoomed out map
      var isRegionConfigurable = Math.abs( $scope.params.nelat ) !== Math.abs( $scope.params.swlat )
        && Math.abs( $scope.params.nelng ) !== Math.abs( $scope.params.swlng );
      $scope.selectedPlaceLayer = new google.maps.Rectangle(
        _.extend( { }, $scope.boundaryBoxStyle, {
          map: $scope.map,
          bounds: {
            north: parseFloat( $scope.params.nelat ),
            south: parseFloat( $scope.params.swlat ),
            east: parseFloat( $scope.params.nelng ),
            west: parseFloat( $scope.params.swlng )
          },
          editable: isRegionConfigurable
        } )
      );
      $scope.drawing.currentShape = "rectangle";
      $scope.initSelectedPlaceLayer( $scope.selectedPlaceLayer );
    } else if ( $scope.params.lat && $scope.params.lng ) {
      var circleRadius = $scope.params.radius ? parseFloat( $scope.params.radius ) * 1000 : 10000;

      $scope.selectedPlaceLayer = new google.maps.Circle(
        _.extend( { }, $scope.boundaryBoxStyle, {
          map: $scope.map,
          radius: circleRadius,
          center: {
            lat: parseFloat( $scope.params.lat ),
            lng: parseFloat( $scope.params.lng )
          },
          editable: true,
          suppressUndo: true
        } )
      );
      $scope.initSelectedPlaceLayer( $scope.selectedPlaceLayer );
      var circleBounds = $scope.getCircleBounds(
        parseFloat( $scope.params.lat ),
        parseFloat( $scope.params.lng ),
        parseFloat( $scope.params.radius )
      );
      $scope.$parent.mapBounds = googleMapsBoundsToObject( circleBounds );
    }
    $scope.$parent.mapLayersInitialized = true;
    if ( align ) {
      setTimeout( function ( ) {
        $scope.alignMap( );
      } );
    }
  };
  $scope.initSelectedPlaceLayer = function ( selectedPlaceLayer ) {
    // called after resizing shape
    selectedPlaceLayer.addListener( "bounds_changed", function ( ) {
      if ( $scope.drawing.dragging ) {
        return;
      }
      if ( $scope.clearCircleIfInvalid( selectedPlaceLayer ) ) {
        return;
      }
      $scope.refreshSelectedPlace( );
      $scope.positionDragDrawingIcon( selectedPlaceLayer );
    } );
    // when there's a region in the query string on initial page load, we need
    // a little time to ensure the shape is drawn before positioning the drag icon
    setTimeout( function ( ) {
      $scope.initDragIcon( $scope.selectedPlaceLayer );
    }, 100 );
  };
  $scope.zoomIn = function ( ) {
    if ( !googleMapsIsLoaded( ) ) return;
    $scope.map.setZoom( $scope.map.getZoom( ) + 1 );
  };
  $scope.zoomOut = function ( ) {
    if ( !googleMapsIsLoaded( ) ) return;
    $scope.map.setZoom( $scope.map.getZoom( ) - 1 );
  };
  $scope.findUserLocation = function ( ) {
    if ( !googleMapsIsLoaded( ) ) return;
    if ( typeof ( navigator.geolocation ) !== "undefined" ) {
      var getCurrentPositionSuccess = function ( location ) {
        $scope.findingUserLocation = false;
        var circle = new google.maps.Circle( {
          center: {
            lat: location.coords.latitude,
            lng: location.coords.longitude
          },
          radius: ( location.accuracy * 10 ) || 1000
        } );
        $scope.map.fitBounds( circle.getBounds( ) );
      };
      var getCurrentPositionFailure = function ( ) {
        alert( I18n.t( "failed_to_find_your_location" ) );
        $scope.findingUserLocation = false;
      };
      $scope.findingUserLocation = true;
      navigator.geolocation.getCurrentPosition(
        getCurrentPositionSuccess,
        getCurrentPositionFailure
      );
    }
  };
  $scope.toggleFullscreen = function ( ) {
    $scope.fullscreen = !$scope.fullscreen;
  };
};
