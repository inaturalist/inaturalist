/* eslint-disable */

iNatAPI.constant( "V2_OBSERVATION_FIELDS", {
  id: true,
  quality_grade: true,
  identifications_count: true,
  faves_count: true,
  comments_count: true,
  time_observed_at: true,
  observed_time_zone: true,
  created_at: true,
  created_time_zone: true,
  created_at_details: "all",
  observed_on: true,
  observed_on_details: "all",
  geoprivacy: true,
  obscured: true,
  location: true,
  place_guess: true,
  private_geojson: true,
  user: {
    id: true,
    login: true,
    icon_url: true
  },
  photos: {
    id: true,
    url: true
  },
  sounds: {
    id: true
  },
  taxon: {
    name: true,
    preferred_common_name: true,
    iconic_taxon_id: true
  }
} );

iNatAPI.constant( "V2_TAXON_FIELDS", {
  ancestry: true,
  ancestor_ids: true,
  ancestors: {
    id: true,
    uuid: true,
    name: true,
    iconic_taxon_name: true,
    is_active: true,
    preferred_common_name: true,
    rank: true,
    rank_level: true
  },
  default_photo: {
    attribution: true,
    license_code: true,
    url: true,
    medium_url: true
  },
  conservation_status: {
    status: true
  },
  establishment_means: {
    establishment_means: true
  },
  iconic_taxon_name: true,
  id: true,
  is_active: true,
  name: true,
  preferred_common_name: true,
  rank: true,
  rank_level: true
} );

iNatAPI.constant( "V2_USER_FIELDS", {
  id: true,
  name: true,
  login: true,
  icon_url: true
} );


iNatAPI.factory(  "ObservationsFactory", [
  "shared",
  "testingApiV2",
  "V2_OBSERVATION_FIELDS",
  "V2_TAXON_FIELDS",
  "V2_USER_FIELDS",
  function(
    shared,
    testingApiV2,
    V2_OBSERVATION_FIELDS,
    V2_TAXON_FIELDS,
    V2_USER_FIELDS
  ) {
  var show = function( id, params ) {
    var url = "/observations/" + id;
    return shared.basicGet( url, _.extend( { }, params, { fields: V2_OBSERVATION_FIELDS } ) );
  };
  var search = function( params ) {
    var url = "/observations";
    return shared.basicGet( url, _.extend( { }, params, { fields: V2_OBSERVATION_FIELDS } ) );
  };
  var speciesCounts = function( params ) {
    var url = "/observations/species_counts";
    return shared.basicGet( url, _.extend( { }, params, { fields: { taxon: V2_TAXON_FIELDS } } ) );
  };
  var identifiers = function( params ) {
    var url = "/observations/identifiers";
    return shared.basicGet( url, _.extend( { }, params, { fields: { user: V2_USER_FIELDS } } ) );
  };
  var observers = function( params ) {
    var url = "/observations/observers";
    return shared.basicGet( url, _.extend( { }, params, { fields: { user: V2_USER_FIELDS } } ) );
  };
  var responseToInstances = function( response ) {
    if( !( response && response.data && response.data.results ) ) {
      return { };
    }
    return _.map( response.data.results, function( r ) {
      return new iNatModels.Observation( r );
    });
  };
  // Convert an object literal of observation API parameters to keys and
  // values suitable for submission to the observations API endpoints
  var processParamsForAPI = function( p, possibleFields ) {
    var params = _.extend( { }, this.processParams( p, possibleFields ) );
    if( p.per_page ) { params.per_page = p.per_page; }
    return params;
  };
  // Normalizes an object literal of observation query parameters into
  // something almost suitable for display to the user or submission to the
  // API. Since how params are displayed to the user will be controller-
  // specific, see the controllers for implementations (e.g.
  // updateBrowserLocation in ObservationsSearch.SearchController)
  var processParams = function( p, possibleFields ) {
    var params = _.extend( { }, p );
    // deal with iconic taxa
    var keysToDelete = [ "taxon_name" ];
    if( params._iconic_taxa ) {
      var iconic_taxa = [ ];
      angular.forEach( params._iconic_taxa, function( selected, name ) {
        if( selected ) {
          iconic_taxa.push( name )
        }
      });
      if( iconic_taxa.length > 0 ) {
        params.iconic_taxa = iconic_taxa;
      } else {
        params.iconic_taxa = [ ];
      }
      keysToDelete.push( "_iconic_taxa" );
    }
    // date types
    // this looks and feels horrible, but I'm not sure what the angular way of doing it would be
    switch( params.dateType ) {
      case 'exact':
        keysToDelete = keysToDelete.concat([ "d1", "d2", "month" ]);
        break;
      case 'range':
        keysToDelete = keysToDelete.concat([ "on", "month" ]);
        break;
      case 'month':
        keysToDelete = keysToDelete.concat([ "on", "d1", "d2" ]);
        break;
      default:
        keysToDelete = keysToDelete.concat([ "on", "d1", "d2", "month" ]);
    }
    keysToDelete.push( "dateType" );
    switch( params.createdDateType ) {
      case 'exact':
        keysToDelete = keysToDelete.concat([ "created_d1", "created_d2" ]);
        break;
      case 'range':
        keysToDelete = keysToDelete.concat([ "created_on" ]);
        break;
      case 'month':
        keysToDelete = keysToDelete.concat([ "created_on", "created_d1", "created_d2" ]);
        break;
      default:
        keysToDelete = keysToDelete.concat([ "created_on", "created_d1", "created_d2" ]);
    }
    keysToDelete.push( "createdDateType" );
    if ( params.observationFields ) {
      // remove all existing observation field params
      _.each( _.keys( params ), function( k ) {
        if ( k.match( /field:.+/ ) ) {
          delete params[ k ];
        }
      })
      // add the ones that are actually in the scope
      _.each( params.observationFields, function( v, k ) {
        params[k] = v || "";
      });
      // make sure we don't keep around this stuff from the scope
      keysToDelete.push( "observationFields" );
    }
    if( possibleFields ) {
      var unknownFields = _.difference( _.keys( params ), possibleFields );
      _.each( unknownFields, function( f ) {
        if ( !f.match( /field:.+/ ) ) {
          delete params[ f ];
        }
      });
    }
    _.each( _.keys( params ), function( k ) {
      if( k == "verifiable" ) { return; }
      // _.isEmpty returns true for ints and floats
      if( _.isEmpty( params[ k ] ) && !_.isBoolean( params[ k ] )
          && !_.isNumber( params[ k ] ) ) {
        keysToDelete.push( k );
      }
    });
    _.each( keysToDelete, function( k ) {
      if ( !k.match( /field:.+/ ) ) {
        delete params[ k ];
      }
    });
    // use the current user's id as the basis for the `reviewed` param
    if( !_.isUndefined( params.reviewed ) && !params.viewer_id && CURRENT_USER ) {
      params.viewer_id = CURRENT_USER.id;
    }
    // remove any params that are null, undefined, or whose value is "any"
    // as they will not affect search results and are not allowed in APIv2
    return _.omitBy( params, function( value ) {
      return value === "any" || _.isNull( value ) || _.isUndefined( value );
    } );
  };
  var hasSpatialParams = function( params ) {
    return params.place_id || params.latitude || params.lat || params.swlat;
  };
  return {
    show: show,
    search: search,
    speciesCounts: speciesCounts,
    identifiers: identifiers,
    observers: observers,
    responseToInstances: responseToInstances,
    processParams: processParams,
    processParamsForAPI: processParamsForAPI,
    hasSpatialParams: hasSpatialParams
  };
}]);
